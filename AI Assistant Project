import speech_recognition as sr
import webbrowser
import pyttsx3
import musicLibrary
import requests
from gtts import gTTS
import pygame
import os
import logging
from datetime import datetime
from typing import Optional

class JarvisAssistant:
    def __init__(self):
        """Initialize Jarvis with Google Gemini, News API, and Weather API"""
        self.setup_logging()
        self.initialize_components()

        # Your API keys (replace with your own)
        self.gemini_api_key = "ENTER_YOUR_API_KEY"
        self.news_api_key = "ENTER_YOUR_API_KEY"
        self.weather_api_key = "ENTER_YOUR_API_KEY"

    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[logging.FileHandler('jarvis.log'), logging.StreamHandler()]
        )
        self.logger = logging.getLogger(__name__)

    def initialize_components(self):
        self.recognizer = sr.Recognizer()
        self.engine = pyttsx3.init()
        voices = self.engine.getProperty('voices')
        if voices:
            self.engine.setProperty('voice', voices[0].id)
        self.engine.setProperty('rate', 180)
        self.engine.setProperty('volume', 0.8)
        pygame.mixer.init()

    def speak_old(self, text: str):
        try:
            self.engine.say(text)
            self.engine.runAndWait()
        except Exception as e:
            self.logger.error(f"Error in speak_old: {e}")

    def speak(self, text: str):
        try:
            self.logger.info(f"Speaking: {text}")
            tts = gTTS(text=text, lang='en', slow=False)
            audio_file = f'temp_{datetime.now().strftime("%Y%m%d_%H%M%S")}.mp3'
            tts.save(audio_file)
            pygame.mixer.music.load(audio_file)
            pygame.mixer.music.play()
            while pygame.mixer.music.get_busy():
                pygame.time.Clock().tick(10)
            pygame.mixer.music.unload()
            if os.path.exists(audio_file):
                os.remove(audio_file)
        except Exception as e:
            self.logger.error(f"Error in speak: {e}")
            self.speak_old(text)

    def ai_process_gemini(self, command: str) -> str:
        try:
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key={self.gemini_api_key}"
            headers = {'Content-Type': 'application/json'}
            data = {
                "contents": [{
                    "parts": [{
                        "text": f"You are JARVIS, Tony Stark's AI assistant. Be helpful, intelligent, and concise. Respond in 1-2 sentences. User asks: {command}"
                    }]
                }],
                "generationConfig": {
                    "temperature": 0.7,
                    "topK": 40,
                    "topP": 0.95,
                    "maxOutputTokens": 100
                }
            }
            response = requests.post(url, headers=headers, json=data, timeout=10)
            if response.status_code == 200:
                result = response.json()
                if 'candidates' in result and len(result['candidates']) > 0:
                    return result['candidates'][0]['content']['parts'][0]['text'].strip()
            return "I could not process that request."
        except Exception as e:
            self.logger.error(f"Gemini AI error: {e}")
            return "I encountered an error with Gemini AI."

    def get_news(self, country: str = "us", category: str = None) -> None:
        try:
            url = f"https://newsapi.org/v2/top-headlines?country={country}&apiKey={self.news_api_key}"
            if category:
                url += f"&category={category}"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()
                articles = data.get('articles', [])
                if not articles:
                    self.speak("No news articles found.")
                    return
                self.speak(f"Here are the top {min(5, len(articles))} headlines:")
                for i, article in enumerate(articles[:5], 1):
                    title = article.get('title', 'No title available')
                    self.speak(f"News {i}: {title}")
            else:
                self.speak("Sorry, I could not fetch the news.")
        except Exception as e:
            self.logger.error(f"Error fetching news: {e}")
            self.speak("Sorry, there was an error fetching the news.")

    def get_weather(self, city: str = "New York") -> None:
        try:
            url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={self.weather_api_key}&units=metric"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()
                temp = data['main']['temp']
                description = data['weather'][0]['description']
                self.speak(f"The weather in {city} is {description} with a temperature of {temp} degrees Celsius.")
            else:
                self.speak("Sorry, I couldn't fetch the weather information.")
        except Exception as e:
            self.logger.error(f"Error fetching weather: {e}")
            self.speak("Sorry, there was an error fetching the weather.")

    def process_command(self, command: str):
        command_lower = command.lower()
        try:
            if "open google" in command_lower:
                webbrowser.open("https://google.com")
                self.speak("Opening Google")
            elif "open youtube" in command_lower:
                webbrowser.open("https://youtube.com")
                self.speak("Opening YouTube")
            elif "play" in command_lower:
                try:
                    song = command_lower.split(" ", 1)[1]
                    if hasattr(musicLibrary, 'music') and song in musicLibrary.music:
                        link = musicLibrary.music[song]
                        webbrowser.open(link)
                        self.speak(f"Playing {song}")
                    else:
                        self.speak(f"Sorry, I don't have {song} in my music library")
                except IndexError:
                    self.speak("Please specify a song to play")
            elif "news" in command_lower:
                if "tech" in command_lower:
                    self.get_news(category="technology")
                elif "business" in command_lower:
                    self.get_news(category="business")
                else:
                    self.get_news()
            elif "weather" in command_lower:
                if "in" in command_lower:
                    parts = command_lower.split("in")
                    if len(parts) > 1:
                        city = parts[1].strip()
                        self.get_weather(city)
                else:
                    self.get_weather()
            elif "time" in command_lower:
                current_time = datetime.now().strftime("%I:%M %p")
                self.speak(f"The current time is {current_time}")
            elif "date" in command_lower:
                current_date = datetime.now().strftime("%B %d, %Y")
                self.speak(f"Today is {current_date}")
            elif "stop" in command_lower or "exit" in command_lower:
                self.speak("Goodbye! Shutting down JARVIS.")
                return False
            else:
                output = self.ai_process_gemini(command)
                self.speak(output)
        except Exception as e:
            self.logger.error(f"Error processing command: {e}")
            self.speak("Sorry, I encountered an error processing your command.")
        return True

    def listen_for_wake_word(self, timeout: int = 5, phrase_time_limit: int = 3) -> bool:
        """Listen for the wake word 'Jarvis'."""
        try:
            with sr.Microphone() as source:
                print("Adjusting for ambient noise, please wait...")
                self.recognizer.adjust_for_ambient_noise(source, duration=1.5)
                print("Listening for wake word...")
                audio = self.recognizer.listen(source, timeout=timeout, phrase_time_limit=phrase_time_limit)
            word = self.recognizer.recognize_google(audio).lower()
            print(f"Heard: {word}")
            return "jarvis" in word
        except sr.WaitTimeoutError:
            print("Listening timed out. No input detected.")
        except sr.UnknownValueError:
            print("Could not understand audio.")
        except sr.RequestError as e:
            print(f"Could not request results from Google Speech Recognition service; {e}")
        return False

    def listen_for_command(self, timeout: int = 10, phrase_time_limit: int = 5) -> Optional[str]:
        """Listen for a command after the wake word is detected."""
        try:
            with sr.Microphone() as source:
                print("Listening for your command...")
                self.recognizer.adjust_for_ambient_noise(source, duration=1.0)
                audio = self.recognizer.listen(source, timeout=timeout, phrase_time_limit=phrase_time_limit)
            command = self.recognizer.recognize_google(audio)
            print(f"Heard command: {command}")
            return command
        except sr.WaitTimeoutError:
            print("Listening timed out. No command detected.")
        except sr.UnknownValueError:
            print("Could not understand audio.")
        except sr.RequestError as e:
            print(f"Could not request results from Google Speech Recognition service; {e}")
        return None

    def run(self):
        print("ü§ñ JARVIS Online with Gemini, News API, and Weather API")
        self.speak("JARVIS initialized and ready.")

        # Wait for wake word once
        while True:
            try:
                print("\nüîä Listening for wake word...")
                if self.listen_for_wake_word():
                    self.speak("Yes, I am listening. You do not need to call me again.")

                    # Continuous command mode until user says stop or exit
                    while True:
                        command = self.listen_for_command()
                        if command:
                            print(f"üìù Command: {command}")
                            if not self.process_command(command):
                                return  # Exit completely
            except KeyboardInterrupt:
                self.speak("Shutting down JARVIS. Goodbye!")
                break

if __name__ == "__main__":
    jarvis = JarvisAssistant()
    jarvis.run()
